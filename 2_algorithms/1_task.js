/*

1.
Про подход

 - Задача легче всего мыслится в категорях ООП, оптимальнее ее именно в ООП делать
 - В функциональном стиле тоже можно, но с состояниями не так удобно будет работать
 - А вот в процедурном никогда не писал, немного почитал про него,
  интересно фидбэк именно по нему получить,  
  поэтому попробовал использовать процедурный подход

2.
Про алгоритм

Дано:
А = кол-во сковород
Б = кол-во панкейков
С = время прожарки одной стороны панкейка
Д = счетчик итераций, начальное значение = 0
СетА = набор из А сковород
СетБ = набор из Б панкейков

Описание алгоритма:
1) Добыли А штук сковород (СетА) и Б штук панкейков (СетБ)
2) Положили в каждую сковороду из СетА по панкейку из СетБ верхней стороной вниз
3) Подождали С минут
4) Перевернули все панкейки на сковородах из СетА нижнний стороной вниз
5) Подождали С минут
6) Из каждой сковороды из СетА убрать готовый панкейк
7) Увеличиваем счетчик итераций Д на 1
8) Проверяем СетБ, если там остался хотя бы один панкейк,
то переходим обратно на 2-ой шаг. В противном случае идем далее
9) Заканчиваем выполнение алгоритма. Текущее значение Д будет результатом  

Примечание: 

Осознанно не стал более подробно описывать алгоритм,
текущий уровень подробности вроде достаточен.

А так можно еще отдельно акцентировать внимание:
- на включении, разогреве и выключении конфорок
- то куда мы складываем готовые панкейки, в конечном счете все ради них делается
- на том положили или убрали сковородки с конфорок
- можно еще помыть сковородки
- и мб еще чего

*/

const cookingInitialze = require('./utils/cookingInitialze');
const startCookingIteration = require('./utils/startCookingIteration');

const memoryHeap = {
  pansCount: 2, // Начальное кол-во сковородок
  pancakesCount: 3, // Начальное кол-во панкейков
  iterationCounter: 0, // Счетчик итераций
  delay: 500 // Время жарки одной стороны панкейков
};

function main() {
  cookingInitialze(memoryHeap);
  startCookingIteration(memoryHeap);
}

main();
